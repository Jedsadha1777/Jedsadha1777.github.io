<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized Canvas IDE POC</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: #2c2c2c; overflow: hidden; }
        .container { display: flex; height: 100vh; }
        .toolbar { width: 60px; background: #1e1e1e; border-right: 1px solid #444; display: flex; flex-direction: column; padding: 10px 0; gap: 10px; }
        .tool-btn { width: 40px; height: 40px; background: #333; border: none; border-radius: 6px; color: white; cursor: pointer; margin: 0 auto; display: flex; align-items: center; justify-content: center; font-size: 18px; }
        .tool-btn:hover { background: #444; }
        .tool-btn.active { background: #0066cc; }
        .canvas-container { flex: 1; position: relative; overflow: hidden; }
        #canvas { 
            cursor: grab; 
            background: #f5f5f5; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            user-select: none;
            -webkit-user-drag: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .info { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; }
        .debug-info { position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 4px; font-size: 11px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <button class="tool-btn active" data-tool="select">↖</button>
            <button class="tool-btn" data-tool="rectangle">⬜</button>
            <button class="tool-btn" data-tool="circle">⚪</button>
            <button class="tool-btn" data-tool="pan">✋</button>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
            <div class="info">
                <div>Objects: <span id="objectCount">0</span></div>
                <div>Zoom: <span id="zoomLevel">100%</span></div>
                <div style="margin-top: 8px; font-size: 10px; opacity: 0.8;">
                    Delete: Right-click or Del key
                </div>
            </div>
            <div class="debug-info">
                <div>Grid Cells: <span id="gridCells">0</span></div>
                <div>Dirty Rects: <span id="dirtyRects">0</span></div>
                <div>Render: <span id="renderTime">0ms</span></div>
                <div style="margin-top: 8px; font-size: 10px; opacity: 0.8;">
                    Snap: Press 'G' to toggle (<span id="snapStatus">ON</span>)
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== SPATIAL GRID ==========
        class SpatialGrid {
            constructor(cellSize = 100) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }

            getCellKey(x, y) {
                return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`;
            }

            addObject(id, x, y, width, height) {
                const startX = Math.floor(x / this.cellSize);
                const startY = Math.floor(y / this.cellSize);
                const endX = Math.floor((x + width) / this.cellSize);
                const endY = Math.floor((y + height) / this.cellSize);

                for (let cellX = startX; cellX <= endX; cellX++) {
                    for (let cellY = startY; cellY <= endY; cellY++) {
                        const key = `${cellX},${cellY}`;
                        if (!this.grid.has(key)) this.grid.set(key, new Set());
                        this.grid.get(key).add(id);
                    }
                }
            }

            removeObject(id, x, y, width, height) {
                const startX = Math.floor(x / this.cellSize);
                const startY = Math.floor(y / this.cellSize);
                const endX = Math.floor((x + width) / this.cellSize);
                const endY = Math.floor((y + height) / this.cellSize);

                for (let cellX = startX; cellX <= endX; cellX++) {
                    for (let cellY = startY; cellY <= endY; cellY++) {
                        const key = `${cellX},${cellY}`;
                        if (this.grid.has(key)) {
                            this.grid.get(key).delete(id);
                            if (this.grid.get(key).size === 0) this.grid.delete(key);
                        }
                    }
                }
            }

            getObjectsAt(x, y) {
                return this.grid.get(this.getCellKey(x, y)) || new Set();
            }

            getCellCount() { return this.grid.size; }
        }

        // ========== DIRTY RECT MANAGER ==========
        class DirtyRectManager {
            constructor() { this.dirtyRects = []; }
            addDirtyRect(x, y, width, height) { this.dirtyRects.push({ x, y, width, height }); }
            clear() { this.dirtyRects = []; }
            getDirtyRects() { return this.dirtyRects; }
        }

        // ========== FLAT OBJECT STORE ==========
        class ObjectStore {
            constructor() {
                this.ids = [];
                this.types = [];
                this.x = [];
                this.y = [];
                this.width = [];
                this.height = [];
                this.colors = [];
                this.selected = [];
                this.nextId = 0;
            }

            createObject(type, x, y, width, height, color = '#3498db') {
                const index = this.ids.length;
                const id = this.nextId++;
                
                this.ids[index] = id;
                this.types[index] = type;
                this.x[index] = x;
                this.y[index] = y;
                this.width[index] = width;
                this.height[index] = height;
                this.colors[index] = color;
                this.selected[index] = false;

                return { id, index };
            }

            contains(index, px, py) {
                return px >= this.x[index] && px <= this.x[index] + this.width[index] &&
                       py >= this.y[index] && py <= this.y[index] + this.height[index];
            }

            draw(ctx, index) {
                ctx.fillStyle = this.colors[index];
                
                if (this.types[index] === 'rectangle') {
                    ctx.fillRect(this.x[index], this.y[index], this.width[index], this.height[index]);
                } else if (this.types[index] === 'circle') {
                    ctx.beginPath();
                    const centerX = this.x[index] + this.width[index]/2;
                    const centerY = this.y[index] + this.height[index]/2;
                    const radius = Math.min(this.width[index], this.height[index])/2;
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Selection outline
                if (this.selected[index]) {
                    ctx.strokeStyle = '#0066cc';
                    ctx.lineWidth = 2 / editor.zoom;
                    ctx.setLineDash([5 / editor.zoom, 5 / editor.zoom]);
                    ctx.strokeRect(this.x[index], this.y[index], this.width[index], this.height[index]);
                    ctx.setLineDash([]);
                }
            }
        }

        // ========== MAIN EDITOR ==========
        class OptimizedCanvasEditor {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.objects = new ObjectStore();
                this.spatialGrid = new SpatialGrid(100);
                this.dirtyManager = new DirtyRectManager();
                
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.selectedIndex = -1;
                this.currentTool = 'select';
                
                // Grid snapping
                this.gridSize = 20;
                this.snapEnabled = true;
                
                this.isDragging = false;
                this.isDrawing = false;
                this.isPanning = false;
                this.startX = 0;
                this.startY = 0;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;

                this.setupEventListeners();
                this.render();
                this.updateInfo();
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('wheel', this.onWheel.bind(this));

                // Prevent default drag behavior
                this.canvas.addEventListener('dragstart', (e) => e.preventDefault());
                this.canvas.addEventListener('selectstart', (e) => e.preventDefault());

                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelector('.tool-btn.active').classList.remove('active');
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                    });
                });

                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.resetAllStates();
                    }
                    
                    if (e.key === 'Delete' && this.selectedIndex !== -1) {
                        this.deleteSelected();
                    }
                    
                    if (e.key === 'g' || e.key === 'G') {
                        this.snapEnabled = !this.snapEnabled;
                        this.updateInfo();
                    }
                });

                // Global safety mouseup
                document.addEventListener('mouseup', () => {
                    if (this.isDragging || this.isDrawing || this.isPanning) {
                        this.resetAllStates();
                    }
                });

                // Right click to delete
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const pos = this.screenToCanvas(e.clientX, e.clientY);
                    const clickedIndex = this.getObjectAt(pos.x, pos.y);
                    if (clickedIndex !== -1) {
                        this.deleteObject(clickedIndex);
                    }
                });
            }

            resetAllStates() {
                this.isDragging = false;
                this.isDrawing = false;
                this.isPanning = false;
                this.render(); // Clean render to remove any artifacts
            }

            snapPosition(x, y) {
                if (!this.snapEnabled) return { x, y };
                return {
                    x: Math.round(x / this.gridSize) * this.gridSize,
                    y: Math.round(y / this.gridSize) * this.gridSize
                };
            }

            screenToCanvas(screenX, screenY) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: (screenX - rect.left - this.panX) / this.zoom,
                    y: (screenY - rect.top - this.panY) / this.zoom
                };
            }

            onMouseDown(e) {
                // Block ALL modifier key combinations
                if (e.metaKey || e.ctrlKey || e.altKey || e.shiftKey) {
                    e.preventDefault();
                    e.stopPropagation();
                    return; // Exit early - don't start any drag operations
                }
                
                const pos = this.screenToCanvas(e.clientX, e.clientY);
                this.startX = pos.x;
                this.startY = pos.y;

                if (this.currentTool === 'select') {
                    const clickedIndex = this.getObjectAt(pos.x, pos.y);
                    if (clickedIndex !== -1) {
                        this.selectObject(clickedIndex);
                        this.isDragging = true;
                        this.dragOffsetX = pos.x - this.objects.x[clickedIndex];
                        this.dragOffsetY = pos.y - this.objects.y[clickedIndex];
                    } else {
                        this.selectObject(-1);
                    }
                } else if (this.currentTool === 'rectangle' || this.currentTool === 'circle') {
                    this.isDrawing = true;
                } else if (this.currentTool === 'pan') {
                    this.isPanning = true;
                    this.lastPanX = e.clientX;
                    this.lastPanY = e.clientY;
                }
            }

            onMouseMove(e) {
                // Safety check - if modifier keys are pressed, reset all states
                if (e.metaKey || e.ctrlKey || e.altKey || e.shiftKey) {
                    this.resetAllStates();
                    return;
                }

                // Additional safety - check if mouse button is actually pressed
                if (this.isDragging && e.buttons === 0) {
                    this.resetAllStates();
                    return;
                }
                
                const pos = this.screenToCanvas(e.clientX, e.clientY);

                if (this.isDragging && this.selectedIndex !== -1) {
                    const i = this.selectedIndex;
                    
                    this.addDirtyRect(this.objects.x[i], this.objects.y[i], 
                                    this.objects.width[i], this.objects.height[i]);
                    
                    this.spatialGrid.removeObject(i, this.objects.x[i], this.objects.y[i], 
                                                this.objects.width[i], this.objects.height[i]);
                    
                    const newX = pos.x - this.dragOffsetX;
                    const newY = pos.y - this.dragOffsetY;
                    const snappedPos = this.snapPosition(newX, newY);
                    
                    this.objects.x[i] = snappedPos.x;
                    this.objects.y[i] = snappedPos.y;
                    
                    this.spatialGrid.addObject(i, this.objects.x[i], this.objects.y[i], 
                                            this.objects.width[i], this.objects.height[i]);
                    
                    this.addDirtyRect(this.objects.x[i], this.objects.y[i], 
                                    this.objects.width[i], this.objects.height[i]);
                    
                    this.optimizedRender();
                    
                } else if (this.isDrawing) {
                    this.render();
                    this.drawPreview(this.startX, this.startY, pos.x - this.startX, pos.y - this.startY);
                    
                } else if (this.isPanning) {
                    this.panX += e.clientX - this.lastPanX;
                    this.panY += e.clientY - this.lastPanY;
                    this.lastPanX = e.clientX;
                    this.lastPanY = e.clientY;
                    this.render();
                }
            }

            onMouseUp(e) {
                // Always reset states on mouse up, regardless of modifiers
                this.finishCurrentOperation(e);
            }

            finishCurrentOperation(e) {
                if (this.isDrawing) {
                    const pos = this.screenToCanvas(e.clientX, e.clientY);
                    const width = pos.x - this.startX;
                    const height = pos.y - this.startY;
                    
                    if (Math.abs(width) > 5 && Math.abs(height) > 5) {
                        let x = Math.min(this.startX, pos.x);
                        let y = Math.min(this.startY, pos.y);
                        let w = Math.abs(width);
                        let h = Math.abs(height);

                        if (this.snapEnabled) {
                            const snappedPos = this.snapPosition(x, y);
                            const snappedEnd = this.snapPosition(x + w, y + h);
                            x = snappedPos.x;
                            y = snappedPos.y;
                            w = snappedEnd.x - x;
                            h = snappedEnd.y - y;
                        }

                        const { index } = this.objects.createObject(this.currentTool, x, y, w, h);
                        this.spatialGrid.addObject(index, x, y, w, h);
                        this.selectObject(index);
                        this.updateInfo();
                    }
                }

                this.resetAllStates();
            }

            onWheel(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.1, Math.min(5, this.zoom * zoomFactor));

                this.panX = mouseX - (mouseX - this.panX) * (newZoom / this.zoom);
                this.panY = mouseY - (mouseY - this.panY) * (newZoom / this.zoom);
                this.zoom = newZoom;

                this.updateInfo();
                this.render();
            }

            addDirtyRect(x, y, width, height) {
                const padding = 10;
                const screenX = (x * this.zoom) + this.panX - padding;
                const screenY = (y * this.zoom) + this.panY - padding;
                const screenWidth = (width * this.zoom) + (padding * 2);
                const screenHeight = (height * this.zoom) + (padding * 2);
                
                this.dirtyManager.addDirtyRect(screenX, screenY, screenWidth, screenHeight);
            }

            getObjectAt(x, y) {
                // Check from highest index (last drawn) to lowest
                for (let i = this.objects.ids.length - 1; i >= 0; i--) {
                    if (this.objects.contains(i, x, y)) {
                        return i;
                    }
                }
                return -1;
            }

            selectObject(index) {
                if (this.selectedIndex !== -1) {
                    this.objects.selected[this.selectedIndex] = false;
                    this.addDirtyRect(this.objects.x[this.selectedIndex], this.objects.y[this.selectedIndex],
                                     this.objects.width[this.selectedIndex], this.objects.height[this.selectedIndex]);
                }
                
                this.selectedIndex = index;
                
                if (index !== -1) {
                    this.objects.selected[index] = true;
                    this.addDirtyRect(this.objects.x[index], this.objects.y[index],
                                     this.objects.width[index], this.objects.height[index]);
                }
                
                this.optimizedRender();
            }

            optimizedRender() {
                const startTime = performance.now();
                const dirtyRects = this.dirtyManager.getDirtyRects();
                
                if (dirtyRects.length === 0) return;

                dirtyRects.forEach(rect => {
                    this.ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
                    
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.rect(rect.x, rect.y, rect.width, rect.height);
                    this.ctx.clip();

                    this.ctx.scale(this.zoom, this.zoom);
                    this.ctx.translate(this.panX / this.zoom, this.panY / this.zoom);

                    // Draw grid and objects in this region
                    this.drawGrid();
                    for (let i = 0; i < this.objects.ids.length; i++) {
                        this.objects.draw(this.ctx, i);
                    }

                    this.ctx.restore();
                });

                this.dirtyManager.clear();
                
                const renderTime = performance.now() - startTime;
                document.getElementById('renderTime').textContent = renderTime.toFixed(1) + 'ms';
                document.getElementById('dirtyRects').textContent = dirtyRects.length;
            }

            render() {
                const startTime = performance.now();
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                this.ctx.scale(this.zoom, this.zoom);
                this.ctx.translate(this.panX / this.zoom, this.panY / this.zoom);

                // Draw grid
                this.drawGrid();

                // Draw all objects
                for (let i = 0; i < this.objects.ids.length; i++) {
                    this.objects.draw(this.ctx, i);
                }

                this.ctx.restore();
                
                const renderTime = performance.now() - startTime;
                document.getElementById('renderTime').textContent = renderTime.toFixed(1) + 'ms';
                document.getElementById('dirtyRects').textContent = 'Full';
            }

            drawPreview(x, y, width, height) {
                this.ctx.save();
                this.ctx.scale(this.zoom, this.zoom);
                this.ctx.translate(this.panX / this.zoom, this.panY / this.zoom);

                this.ctx.fillStyle = 'rgba(52, 152, 219, 0.5)';
                this.ctx.strokeStyle = '#3498db';
                this.ctx.lineWidth = 1 / this.zoom;

                if (this.currentTool === 'rectangle') {
                    this.ctx.fillRect(x, y, width, height);  // แก้จาก ctx.fillRect
                    this.ctx.strokeRect(x, y, width, height);
                } else if (this.currentTool === 'circle') {
                    this.ctx.beginPath();
                    this.ctx.arc(x + width/2, y + height/2, Math.min(Math.abs(width), Math.abs(height))/2, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                }

                this.ctx.restore();
            }

            drawGrid() {
                const startX = Math.floor(-this.panX / this.zoom / this.gridSize) * this.gridSize;
                const startY = Math.floor(-this.panY / this.zoom / this.gridSize) * this.gridSize;
                const endX = startX + (this.canvas.width / this.zoom) + this.gridSize;
                const endY = startY + (this.canvas.height / this.zoom) + this.gridSize;

                // Grid color based on snap state
                this.ctx.strokeStyle = this.snapEnabled ? '#bbb' : '#eee';
                this.ctx.lineWidth = 0.5 / this.zoom;
                this.ctx.beginPath();

                for (let x = startX; x <= endX; x += this.gridSize) {
                    this.ctx.moveTo(x, startY);
                    this.ctx.lineTo(x, endY);
                }

                for (let y = startY; y <= endY; y += this.gridSize) {
                    this.ctx.moveTo(startX, y);
                    this.ctx.lineTo(endX, y);
                }

                this.ctx.stroke();

                // Draw major grid lines every 100px
                if (this.zoom > 0.5) {
                    const majorGridSize = this.gridSize * 5;
                    const majorStartX = Math.floor(-this.panX / this.zoom / majorGridSize) * majorGridSize;
                    const majorStartY = Math.floor(-this.panY / this.zoom / majorGridSize) * majorGridSize;
                    const majorEndX = majorStartX + (this.canvas.width / this.zoom) + majorGridSize;
                    const majorEndY = majorStartY + (this.canvas.height / this.zoom) + majorGridSize;

                    this.ctx.strokeStyle = this.snapEnabled ? '#999' : '#ddd';
                    this.ctx.lineWidth = 1 / this.zoom;
                    this.ctx.beginPath();

                    for (let x = majorStartX; x <= majorEndX; x += majorGridSize) {
                        this.ctx.moveTo(x, majorStartY);
                        this.ctx.lineTo(x, majorEndY);
                    }

                    for (let y = majorStartY; y <= majorEndY; y += majorGridSize) {
                        this.ctx.moveTo(majorStartX, y);
                        this.ctx.lineTo(majorEndX, y);
                    }

                    this.ctx.stroke();
                }
            }

            deleteSelected() {
                if (this.selectedIndex !== -1) {
                    this.deleteObject(this.selectedIndex);
                }
            }

            deleteObject(index) {
                // Add dirty rect for deleted object
                this.addDirtyRect(this.objects.x[index], this.objects.y[index],
                                 this.objects.width[index], this.objects.height[index]);
                
                // Remove from spatial grid
                this.spatialGrid.removeObject(index, this.objects.x[index], this.objects.y[index], 
                                             this.objects.width[index], this.objects.height[index]);
                
                // Remove from arrays (shift left)
                this.objects.ids.splice(index, 1);
                this.objects.types.splice(index, 1);
                this.objects.x.splice(index, 1);
                this.objects.y.splice(index, 1);
                this.objects.width.splice(index, 1);
                this.objects.height.splice(index, 1);
                this.objects.colors.splice(index, 1);
                this.objects.selected.splice(index, 1);
                
                // Rebuild spatial grid with new indices
                this.rebuildSpatialGrid();
                
                // Update selected index
                if (this.selectedIndex === index) {
                    this.selectedIndex = -1;
                } else if (this.selectedIndex > index) {
                    this.selectedIndex--;
                }
                
                this.updateInfo();
                this.optimizedRender();
            }

            rebuildSpatialGrid() {
                this.spatialGrid = new SpatialGrid(100);
                for (let i = 0; i < this.objects.ids.length; i++) {
                    this.spatialGrid.addObject(i, this.objects.x[i], this.objects.y[i], 
                                              this.objects.width[i], this.objects.height[i]);
                }
            }

            updateInfo() {
                document.getElementById('objectCount').textContent = this.objects.ids.length;
                document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
                document.getElementById('gridCells').textContent = this.spatialGrid.getCellCount();
                document.getElementById('snapStatus').textContent = this.snapEnabled ? 'ON' : 'OFF';
            }
        }

        // Initialize
        const canvas = document.getElementById('canvas');
        const editor = new OptimizedCanvasEditor(canvas);
        window.editor = editor;
    </script>
</body>
</html>